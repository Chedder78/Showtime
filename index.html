<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cyberwave Asteroids</title>
    <meta name="theme-color" content="#0a0410">
    <meta name="description" content="Synthwave Asteroids with cyberpunk aesthetics">
    <link rel="manifest" href="manifest.json">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            overflow: hidden;
            background-color: #0a0410;
            font-family: 'Courier New', monospace;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #uiContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }
        
        .control-area {
            position: absolute;
            bottom: 20px;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            pointer-events: auto;
        }
        
        #joystick {
            left: 30px;
            background: radial-gradient(circle, rgba(0, 255, 255, 0.2) 0%, rgba(0, 255, 255, 0.1) 70%);
            border: 2px solid #00ffff;
        }
        
        #fireButton {
            right: 30px;
            background: radial-gradient(circle, rgba(255, 0, 255, 0.2) 0%, rgba(255, 0, 255, 0.1) 70%);
            border: 2px solid #ff00ff;
        }
        
        #specialButton {
            right: 170px;
            width: 80px;
            height: 80px;
            background: radial-gradient(circle, rgba(255, 255, 0, 0.2) 0%, rgba(255, 255, 0, 0.1) 70%);
            border: 2px solid #ffff00;
        }
        
        .ui-text {
            position: absolute;
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff;
            font-size: 16px;
            padding: 5px;
        }
        
        #scoreDisplay {
            top: 10px;
            left: 10px;
            font-size: 24px;
        }
        
        #levelDisplay {
            top: 40px;
            left: 10px;
        }
        
        #livesDisplay {
            top: 70px;
            left: 10px;
        }
        
        #powerupDisplay {
            top: 100px;
            left: 10px;
        }
        
        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(10, 4, 16, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 3;
        }
        
        .game-over-text {
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
            margin-bottom: 20px;
            font-size: 36px;
            text-align: center;
        }
        
        .button {
            background: linear-gradient(135deg, #9d00ff, #ff00ff);
            border: none;
            color: white;
            padding: 12px 24px;
            margin: 10px;
            border-radius: 25px;
            font-size: 18px;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 0 15px #ff00ff;
        }
        
        #leaderboard {
            margin-top: 20px;
            color: #00ffff;
            width: 80%;
            max-width: 400px;
            text-align: center;
        }
        
        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 5px;
            background-color: rgba(0, 255, 255, 0.1);
            border-radius: 5px;
        }
        
        @media (min-width: 768px) {
            .control-area {
                display: none;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="uiContainer">
        <div id="scoreDisplay" class="ui-text">SCORE: 0</div>
        <div id="levelDisplay" class="ui-text">LEVEL: 1</div>
        <div id="livesDisplay" class="ui-text">LIVES: 3</div>
        <div id="powerupDisplay" class="ui-text">POWER: NONE</div>
        
        <div id="joystick" class="control-area"></div>
        <div id="fireButton" class="control-area"></div>
        <div id="specialButton" class="control-area"></div>
    </div>
    
    <div id="gameOverScreen">
        <h1 class="game-over-text">GAME OVER</h1>
        <h2 id="finalScore" class="game-over-text">SCORE: 0</h2>
        <button id="restartButton" class="button">NEW GAME</button>
        <div id="leaderboard"></div>
    </div>

    <script>
        // Game Constants
        const COLORS = {
            ship: '#00ffff',
            bullet: '#ff00ff',
            enemy: '#ffff00',
            particle: '#9d00ff',
            background: '#0a0410',
            cityLight: '#2a0b45',
            neonPink: '#ff00ff',
            neonBlue: '#00ffff',
            neonPurple: '#9d00ff'
        };

        // Game State
        const state = {
            width: 0,
            height: 0,
            player: {
                x: 0,
                y: 0,
                angle: 0,
                velocity: { x: 0, y: 0 },
                acceleration: 0.2,
                maxSpeed: 5,
                rotationSpeed: 0.1,
                size: 20,
                lives: 3,
                invulnerable: false,
                invulnerableTimer: 0,
                fireCooldown: 0,
                fireRate: 300,
                specialCooldown: 0,
                specialCharge: 0,
                powerup: null,
                powerupTimer: 0
            },
            bullets: [],
            enemies: [],
            particles: [],
            powerups: [],
            stars: [],
            cityLights: [],
            score: 0,
            level: 1,
            gameTime: 0,
            gameOver: false,
            joystick: {
                active: false,
                angle: 0,
                power: 0,
                x: 0,
                y: 0
            },
            keys: {
                up: false,
                left: false,
                right: false,
                space: false,
                shift: false
            },
            lastTime: 0,
            leaderboard: []
        };

        // DOM Elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const levelDisplay = document.getElementById('levelDisplay');
        const livesDisplay = document.getElementById('livesDisplay');
        const powerupDisplay = document.getElementById('powerupDisplay');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScore = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');
        const leaderboard = document.getElementById('leaderboard');
        const joystickArea = document.getElementById('joystick');
        const fireButton = document.getElementById('fireButton');
        const specialButton = document.getElementById('specialButton');

        // Initialize Game
        function init() {
            resize();
            setupControls();
            setupLeaderboard();
            resetGame();
            requestAnimationFrame(gameLoop);
        }

        // Resize Handler
        function resize() {
            state.width = canvas.width = window.innerWidth;
            state.height = canvas.height = window.innerHeight;
            
            // Position player in center
            state.player.x = state.width / 2;
            state.player.y = state.height / 2;
            
            // Generate background elements
            generateStars();
            generateCityLights();
        }

        // Generate Stars
        function generateStars() {
            state.stars = [];
            const starCount = Math.floor(state.width * state.height / 1000);
            
            for (let i = 0; i < starCount; i++) {
                state.stars.push({
                    x: Math.random() * state.width,
                    y: Math.random() * state.height,
                    size: Math.random() * 1.5 + 0.5,
                    brightness: Math.random() * 0.8 + 0.2,
                    speed: Math.random() * 0.2 + 0.1
                });
            }
        }

        // Generate City Lights
        function generateCityLights() {
            state.cityLights = [];
            const lightCount = Math.floor(state.width / 10);
            const buildingHeight = state.height * 0.3;
            
            for (let i = 0; i < lightCount; i++) {
                state.cityLights.push({
                    x: Math.random() * state.width,
                    width: Math.random() * 30 + 10,
                    height: Math.random() * buildingHeight + buildingHeight * 0.5,
                    brightness: Math.random() * 0.3 + 0.1,
                    speed: Math.random() * 0.5 + 0.2,
                    windows: []
                });
                
                // Add windows to buildings
                const windowCount = Math.floor(state.cityLights[i].width * state.cityLights[i].height / 500);
                for (let j = 0; j < windowCount; j++) {
                    state.cityLights[i].windows.push({
                        x: Math.random() * state.cityLights[i].width,
                        y: Math.random() * state.cityLights[i].height,
                        on: Math.random() > 0.3,
                        brightness: Math.random() * 0.5 + 0.5,
                        flicker: Math.random() * 0.1
                    });
                }
            }
        }

        // Setup Controls
        function setupControls() {
            // Touch controls
            joystickArea.addEventListener('touchstart', handleJoystickStart);
            document.addEventListener('touchmove', handleJoystickMove);
            document.addEventListener('touchend', handleJoystickEnd);
            
            fireButton.addEventListener('touchstart', () => state.keys.space = true);
            fireButton.addEventListener('touchend', () => state.keys.space = false);
            
            specialButton.addEventListener('touchstart', () => state.keys.shift = true);
            specialButton.addEventListener('touchend', () => state.keys.shift = false);
            
            // Keyboard controls
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            // Mouse controls (for desktop)
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mousedown', () => state.keys.space = true);
            canvas.addEventListener('mouseup', () => state.keys.space = false);
            
            // Restart button
            restartButton.addEventListener('click', resetGame);
        }

        // Joystick Handlers
        function handleJoystickStart(e) {
            const touch = e.touches[0];
            const rect = joystickArea.getBoundingClientRect();
            state.joystick.x = rect.left + rect.width / 2;
            state.joystick.y = rect.top + rect.height / 2;
            state.joystick.active = true;
            updateJoystick(touch.clientX, touch.clientY);
            e.preventDefault();
        }

        function handleJoystickMove(e) {
            if (state.joystick.active) {
                const touch = e.touches[0];
                updateJoystick(touch.clientX, touch.clientY);
                e.preventDefault();
            }
        }

        function handleJoystickEnd() {
            state.joystick.active = false;
            state.joystick.power = 0;
        }

        function updateJoystick(touchX, touchY) {
            const dx = touchX - state.joystick.x;
            const dy = touchY - state.joystick.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxDistance = joystickArea.offsetWidth / 2;
            
            state.joystick.angle = Math.atan2(dy, dx);
            state.joystick.power = Math.min(distance / maxDistance, 1);
        }

        // Keyboard Handlers
        function handleKeyDown(e) {
            switch (e.key) {
                case 'ArrowUp': case 'w': case 'W':
                    state.keys.up = true;
                    break;
                case 'ArrowLeft': case 'a': case 'A':
                    state.keys.left = true;
                    break;
                case 'ArrowRight': case 'd': case 'D':
                    state.keys.right = true;
                    break;
                case ' ': case 'Spacebar':
                    state.keys.space = true;
                    break;
                case 'Shift': case 'Control': case 'Alt':
                    state.keys.shift = true;
                    break;
            }
        }

        function handleKeyUp(e) {
            switch (e.key) {
                case 'ArrowUp': case 'w': case 'W':
                    state.keys.up = false;
                    break;
                case 'ArrowLeft': case 'a': case 'A':
                    state.keys.left = false;
                    break;
                case 'ArrowRight': case 'd': case 'D':
                    state.keys.right = false;
                    break;
                case ' ': case 'Spacebar':
                    state.keys.space = false;
                    break;
                case 'Shift': case 'Control': case 'Alt':
                    state.keys.shift = false;
                    break;
            }
        }

        // Mouse Handler
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Calculate angle from player to mouse
            const dx = mouseX - state.player.x;
            const dy = mouseY - state.player.y;
            state.player.angle = Math.atan2(dy, dx);
        }

        // Game Loop
        function gameLoop(timestamp) {
            if (!state.lastTime) state.lastTime = timestamp;
            const deltaTime = timestamp - state.lastTime;
            state.lastTime = timestamp;
            
            if (!state.gameOver) {
                update(deltaTime);
                render();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Update Game State
        function update(deltaTime) {
            state.gameTime += deltaTime;
            
            // Update player
            updatePlayer(deltaTime);
            
            // Update bullets
            updateBullets(deltaTime);
            
            // Update enemies
            updateEnemies(deltaTime);
            
            // Update particles
            updateParticles(deltaTime);
            
            // Update powerups
            updatePowerups(deltaTime);
            
            // Spawn enemies based on level
            if (state.gameTime % (5000 - state.level * 200) < deltaTime && 
                state.enemies.length < 3 + Math.floor(state.level / 2)) {
                spawnEnemy();
            }
            
            // Spawn powerups occasionally
            if (Math.random() < 0.001 && state.powerups.length < 2) {
                spawnPowerup();
            }
            
            // Check level progression
            if (state.score >= state.level * 1000) {
                state.level++;
                levelDisplay.textContent = `LEVEL: ${state.level}`;
            }
        }

        // Update Player
        function updatePlayer(deltaTime) {
            // Handle rotation
            if (state.joystick.active) {
                state.player.angle = state.joystick.angle;
            } else if (state.keys.left) {
                state.player.angle -= state.player.rotationSpeed;
            } else if (state.keys.right) {
                state.player.angle += state.player.rotationSpeed;
            }
            
            // Handle acceleration
            if (state.joystick.active && state.joystick.power > 0.2 || state.keys.up) {
                const power = state.joystick.active ? state.joystick.power : 1;
                state.player.velocity.x += Math.cos(state.player.angle) * state.player.acceleration * power;
                state.player.velocity.y += Math.sin(state.player.angle) * state.player.acceleration * power;
                
                // Limit speed
                const speed = Math.sqrt(state.player.velocity.x * state.player.velocity.x + 
                                      state.player.velocity.y * state.player.velocity.y);
                if (speed > state.player.maxSpeed) {
                    state.player.velocity.x = (state.player.velocity.x / speed) * state.player.maxSpeed;
                    state.player.velocity.y = (state.player.velocity.y / speed) * state.player.maxSpeed;
                }
            }
            
            // Apply friction
            state.player.velocity.x *= 0.98;
            state.player.velocity.y *= 0.98;
            
            // Update position
            state.player.x += state.player.velocity.x;
            state.player.y += state.player.velocity.y;
            
            // Screen wrapping
            if (state.player.x < -state.player.size) state.player.x = state.width + state.player.size;
            if (state.player.x > state.width + state.player.size) state.player.x = -state.player.size;
            if (state.player.y < -state.player.size) state.player.y = state.height + state.player.size;
            if (state.player.y > state.height + state.player.size) state.player.y = -state.player.size;
            
            // Handle firing
            if (state.player.fireCooldown > 0) {
                state.player.fireCooldown -= deltaTime;
            } else if (state.keys.space) {
                fireBullet();
                state.player.fireCooldown = state.player.fireRate;
                
                // Rapid fire powerup
                if (state.player.powerup === 'rapid') {
                    state.player.fireCooldown = state.player.fireRate / 3;
                }
            }
            
            // Handle special ability
            if (state.player.specialCooldown > 0) {
                state.player.specialCooldown -= deltaTime;
            } else if (state.keys.shift && state.player.specialCharge >= 100) {
                activateSpecial();
                state.player.specialCharge = 0;
                state.player.specialCooldown = 5000;
            }
            
            // Charge special ability
            if (state.gameTime % 100 < deltaTime && state.player.specialCharge < 100) {
                state.player.specialCharge += 1;
            }
            
            // Update invulnerability
            if (state.player.invulnerable) {
                state.player.invulnerableTimer -= deltaTime;
                if (state.player.invulnerableTimer <= 0) {
                    state.player.invulnerable = false;
                }
            }
            
            // Update powerup timer
            if (state.player.powerup) {
                state.player.powerupTimer -= deltaTime;
                if (state.player.powerupTimer <= 0) {
                    state.player.powerup = null;
                    powerupDisplay.textContent = "POWER: NONE";
                }
            }
        }

        // Fire Bullet
        function fireBullet() {
            const bulletSpeed = 10;
            const angle = state.player.angle;
            
            // Create bullet
            state.bullets.push({
                x: state.player.x + Math.cos(angle) * state.player.size,
                y: state.player.y + Math.sin(angle) * state.player.size,
                velocity: {
                    x: Math.cos(angle) * bulletSpeed + state.player.velocity.x * 0.5,
                    y: Math.sin(angle) * bulletSpeed + state.player.velocity.y * 0.5
                },
                size: 5,
                life: 1000,
                color: COLORS.bullet
            });
            
            // Triple shot powerup
            if (state.player.powerup === 'triple') {
                for (let i = -1; i <= 1; i += 1) {
                    if (i === 0) continue;
                    const spreadAngle = angle + i * 0.3;
                    state.bullets.push({
                        x: state.player.x + Math.cos(spreadAngle) * state.player.size,
                        y: state.player.y + Math.sin(spreadAngle) * state.player.size,
                        velocity: {
                            x: Math.cos(spreadAngle) * bulletSpeed + state.player.velocity.x * 0.5,
                            y: Math.sin(spreadAngle) * bulletSpeed + state.player.velocity.y * 0.5
                        },
                        size: 5,
                        life: 1000,
                        color: COLORS.bullet
                    });
                }
            }
        }

        // Activate Special Ability
        function activateSpecial() {
            // Shield powerup
            if (state.player.powerup === 'shield') {
                state.player.invulnerable = true;
                state.player.invulnerableTimer = 3000;
                createParticles(state.player.x, state.player.y, 50, COLORS.neonBlue, 2);
            } 
            // Nuke powerup
            else if (state.player.powerup === 'nuke') {
                state.enemies.forEach(enemy => {
                    createExplosion(enemy.x, enemy.y, enemy.size);
                    state.score += 50;
                });
                state.enemies = [];
                createParticles(state.player.x, state.player.y, 100, COLORS.neonPink, 3);
            } 
            // Default EMP blast
            else {
                state.enemies.forEach(enemy => {
                    enemy.stunned = true;
                    enemy.stunTimer = 2000;
                });
                createParticles(state.player.x, state.player.y, 30, COLORS.neonPurple, 1.5);
            }
        }

        // Update Bullets
        function updateBullets(deltaTime) {
            for (let i = state.bullets.length - 1; i >= 0; i--) {
                const bullet = state.bullets[i];
                
                // Update position
                bullet.x += bullet.velocity.x;
                bullet.y += bullet.velocity.y;
                
                // Update lifetime
                bullet.life -= deltaTime;
                
                // Remove if out of bounds or expired
                if (bullet.life <= 0 || 
                    bullet.x < -bullet.size || bullet.x > state.width + bullet.size ||
                    bullet.y < -bullet.size || bullet.y > state.height + bullet.size) {
                    state.bullets.splice(i, 1);
                    continue;
                }
            }
        }

        // Update Enemies
        function updateEnemies(deltaTime) {
            for (let i = state.enemies.length - 1; i >= 0; i--) {
                const enemy = state.enemies[i];
                
                // Update stunned state
                if (enemy.stunned) {
                    enemy.stunTimer -= deltaTime;
                    if (enemy.stunTimer <= 0) {
                        enemy.stunned = false;
                    }
                    continue;
                }
                
                // Move toward player
                const dx = state.player.x - enemy.x;
                const dy = state.player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    enemy.velocity.x += (dx / distance) * enemy.acceleration;
                    enemy.velocity.y += (dy / distance) * enemy.acceleration;
                }
                
                // Limit speed
                const speed = Math.sqrt(enemy.velocity.x * enemy.velocity.x + 
                                       enemy.velocity.y * enemy.velocity.y);
                if (speed > enemy.maxSpeed) {
                    enemy.velocity.x = (enemy.velocity.x / speed) * enemy.maxSpeed;
                    enemy.velocity.y = (enemy.velocity.y / speed) * enemy.maxSpeed;
                }
                
                // Apply friction
                enemy.velocity.x *= 0.99;
                enemy.velocity.y *= 0.99;
                
                // Update position
                enemy.x += enemy.velocity.x;
                enemy.y += enemy.velocity.y;
                
                // Screen wrapping
                if (enemy.x < -enemy.size) enemy.x = state.width + enemy.size;
                if (enemy.x > state.width + enemy.size) enemy.x = -enemy.size;
                if (enemy.y < -enemy.size) enemy.y = state.height + enemy.size;
                if (enemy.y > state.height + enemy.size) enemy.y = -enemy.size;
                
                // Check collision with player
                if (!state.player.invulnerable) {
                    const playerDx = state.player.x - enemy.x;
                    const playerDy = state.player.y - enemy.y;
                    const playerDistance = Math.sqrt(playerDx * playerDx + playerDy * playerDy);
                    
                    if (playerDistance < state.player.size + enemy.size) {
                        playerHit();
                    }
                }
                
                // Check collision with bullets
                for (let j = state.bullets.length - 1; j >= 0; j--) {
                    const bullet = state.bullets[j];
                    const bulletDx = bullet.x - enemy.x;
                    const bulletDy = bullet.y - enemy.y;
                    const bulletDistance = Math.sqrt(bulletDx * bulletDx + bulletDy * bulletDy);
                    
                    if (bulletDistance < enemy.size + bullet.size) {
                        // Hit!
                        state.bullets.splice(j, 1);
                        enemy.health--;
                        
                        if (enemy.health <= 0) {
                            createExplosion(enemy.x, enemy.y, enemy.size);
                            state.score += 100;
                            state.player.specialCharge += 10;
                            state.enemies.splice(i, 1);
                        }
                        
                        break;
                    }
                }
            }
        }

        // Player Hit
        function playerHit() {
            state.player.lives--;
            livesDisplay.textContent = `LIVES: ${state.player.lives}`;
            
            if (state.player.lives <= 0) {
                gameOver();
                return;
            }
            
            // Make player invulnerable for a short time
            state.player.invulnerable = true;
            state.player.invulnerableTimer = 2000;
            
            // Create explosion
            createExplosion(state.player.x, state.player.y, state.player.size * 1.5);
            
            // Reset position
            state.player.x = state.width / 2;
            state.player.y = state.height / 2;
            state.player.velocity.x = 0;
            state.player.velocity.y = 0;
        }

        // Game Over
        function gameOver() {
            state.gameOver = true;
            finalScore.textContent = `SCORE: ${state.score}`;
            gameOverScreen.style.display = 'flex';
            updateLeaderboard();
        }

        // Reset Game
        function resetGame() {
            // Reset game state
            state.player = {
                x: state.width / 2,
                y: state.height / 2,
                angle: 0,
                velocity: { x: 0, y: 0 },
                acceleration: 0.2,
                maxSpeed: 5,
                rotationSpeed: 0.1,
                size: 20,
                lives: 3,
                invulnerable: false,
                invulnerableTimer: 0,
                fireCooldown: 0,
                fireRate: 300,
                specialCooldown: 0,
                specialCharge: 0,
                powerup: null,
                powerupTimer: 0
            };
            
            state.bullets = [];
            state.enemies = [];
            state.particles = [];
            state.powerups = [];
            state.score = 0;
            state.level = 1;
            state.gameTime = 0;
            state.gameOver = false;
            
            // Reset UI
            scoreDisplay.textContent = `SCORE: 0`;
            levelDisplay.textContent = `LEVEL: 1`;
            livesDisplay.textContent = `LIVES: 3`;
            powerupDisplay.textContent = `POWER: NONE`;
            gameOverScreen.style.display = 'none';
        }

        // Spawn Enemy
        function spawnEnemy() {
            // Choose spawn point at edge of screen
            let x, y;
            if (Math.random() < 0.5) {
                x = Math.random() < 0.5 ? -30 : state.width + 30;
                y = Math.random() * state.height;
            } else {
                x = Math.random() * state.width;
                y = Math.random() < 0.5 ? -30 : state.height + 30;
            }
            
            const size = Math.random() * 20 + 20;
            const health = Math.floor(state.level / 3) + 1;
            
            state.enemies.push({
                x,
                y,
                size,
                health,
                velocity: { x: 0, y: 0 },
                acceleration: 0.05 + Math.random() * 0.05,
                maxSpeed: 2 + Math.random() * 1,
                color: COLORS.enemy,
                stunned: false,
                stunTimer: 0
            });
        }

        // Spawn Powerup
        function spawnPowerup() {
            const types = ['shield', 'rapid', 'triple', 'nuke'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            state.powerups.push({
                x: Math.random() * (state.width - 100) + 50,
                y: Math.random() * (state.height - 100) + 50,
                size: 15,
                type,
                life: 10000,
                color: type === 'shield' ? COLORS.neonBlue : 
                      type === 'rapid' ? COLORS.neonPink :
                      type === 'triple' ? COLORS.neonPurple : 
                      '#ffff00'
            });
        }

        // Update Powerups
        function updatePowerups(deltaTime) {
            for (let i = state.powerups.length - 1; i >= 0; i--) {
                const powerup = state.powerups[i];
                
                // Update lifetime
                powerup.life -= deltaTime;
                
                // Remove if expired
                if (powerup.life <= 0) {
                    state.powerups.splice(i, 1);
                    continue;
                }
                
                // Check collision with player
                const dx = state.player.x - powerup.x;
                const dy = state.player.y - powerup.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < state.player.size + powerup.size) {
                    // Collect powerup
                    state.player.powerup = powerup.type;
                    state.player.powerupTimer = 15000;
                    powerupDisplay.textContent = `POWER: ${powerup.type.toUpperCase()}`;
                    
                    // Create collection effect
                    createParticles(powerup.x, powerup.y, 30, powerup.color, 1.5);
                    
                    // Remove powerup
                    state.powerups.splice(i, 1);
                }
            }
        }

        // Create Explosion
        function createExplosion(x, y, size) {
            const particleCount = Math.floor(size * 2);
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                const life = Math.random() * 1000 + 500;
                
                state.particles.push({
                    x,
                    y,
                    velocity: {
                        x: Math.cos(angle) * speed,
                        y: Math.sin(angle) * speed
                    },
                    size: Math.random() * 3 + 1,
                    life,
                    maxLife: life,
                    color: COLORS.particle
                });
            }
        }

        // Create Particles
        function createParticles(x, y, count, color, speedMultiplier = 1) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 2 * speedMultiplier + 0.5 * speedMultiplier;
                const life = Math.random() * 500 + 300;
                
                state.particles.push({
                    x,
                    y,
                    velocity: {
                        x: Math.cos(angle) * speed,
                        y: Math.sin(angle) * speed
                    },
                    size: Math.random() * 2 + 1,
                    life,
                    maxLife: life,
                    color
                });
            }
        }

        // Update Particles
        function updateParticles(deltaTime) {
            for (let i = state.particles.length - 1; i >= 0; i--) {
                const particle = state.particles[i];
                
                // Update position
                particle.x += particle.velocity.x;
                particle.y += particle.velocity.y;
                
                // Apply friction
                particle.velocity.x *= 0.98;
                particle.velocity.y *= 0.98;
                
                // Update lifetime
                particle.life -= deltaTime;
                
                // Remove if expired
                if (particle.life <= 0) {
                    state.particles.splice(i, 1);
                }
            }
        }

        // Render Game
        function render() {
            // Clear canvas
            ctx.fillStyle = COLORS.background;
            ctx.fillRect(0, 0, state.width, state.height);
            
            // Draw stars
            drawStars();
            
            // Draw city lights
            drawCityLights();
            
            // Draw particles
            drawParticles();
            
            // Draw powerups
            drawPowerups();
            
            // Draw enemies
            drawEnemies();
            
            // Draw bullets
            drawBullets();
            
            // Draw player
            drawPlayer();
            
            // Draw UI
            drawUI();
        }

        // Draw Stars
        function drawStars() {
            ctx.save();
            state.stars.forEach(star => {
                const alpha = star.brightness * 0.8 + Math.sin(state.gameTime / 500) * 0.2;
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.fillRect(star.x, star.y, star.size, star.size);
                
                // Move stars for parallax effect
                star.y += star.speed;
                if (star.y > state.height) {
                    star.y = 0;
                    star.x = Math.random() * state.width;
                }
            });
            ctx.restore();
        }

        // Draw City Lights
        function drawCityLights() {
            ctx.save();
            state.cityLights.forEach(building => {
                // Draw building
                ctx.fillStyle = `rgba(42, 11, 69, ${building.brightness})`;
                ctx.fillRect(building.x, state.height - building.height, building.width, building.height);
                
                // Draw windows
                building.windows.forEach(window => {
                    if (window.on) {
                        const brightness = window.brightness + Math.sin(state.gameTime / 200) * window.flicker;
                        ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
                        ctx.fillRect(
                            building.x + window.x,
                            state.height - building.height + window.y,
                            2, 2
                        );
                    }
                });
                
                // Move buildings for parallax effect
                building.x -= building.speed;
                if (building.x < -building.width) {
                    building.x = state.width;
                }
            });
            ctx.restore();
        }

        // Draw Particles
        function drawParticles() {
            ctx.save();
            state.particles.forEach(particle => {
                const alpha = particle.life / particle.maxLife;
                ctx.fillStyle = `${particle.color.replace(')', `, ${alpha})`)}`;
                ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
            });
            ctx.restore();
        }

        // Draw Powerups
        function drawPowerups() {
            ctx.save();
            state.powerups.forEach(powerup => {
                // Pulsing effect
                const pulse = Math.sin(state.gameTime / 200) * 2 + 3;
                
                // Draw outer glow
                ctx.beginPath();
                ctx.arc(powerup.x, powerup.y, powerup.size + pulse, 0, Math.PI * 2);
                ctx.fillStyle = `${powerup.color.replace(')', `, 0.2)`)}`;
                ctx.fill();
                
                // Draw powerup
                ctx.beginPath();
                ctx.arc(powerup.x, powerup.y, powerup.size, 0, Math.PI * 2);
                ctx.fillStyle = powerup.color;
                ctx.fill();
                
                // Draw icon based on type
                ctx.fillStyle = '#000';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = 'bold 12px Arial';
                
                let symbol = '';
                switch (powerup.type) {
                    case 'shield': symbol = 'S'; break;
                    case 'rapid': symbol = 'R'; break;
                    case 'triple': symbol = 'T'; break;
                    case 'nuke': symbol = 'N'; break;
                }
                
                ctx.fillText(symbol, powerup.x, powerup.y);
            });
            ctx.restore();
        }

        // Draw Enemies
        function drawEnemies() {
            ctx.save();
            state.enemies.forEach(enemy => {
                // Draw enemy
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
                
                if (enemy.stunned) {
                    // Flashing effect when stunned
                    ctx.fillStyle = state.gameTime % 200 < 100 ? '#ffffff' : enemy.color;
                } else {
                    ctx.fillStyle = enemy.color;
                }
                
                ctx.fill();
                
                // Draw health indicator
                if (enemy.health > 1) {
                    ctx.fillStyle = '#ff0000';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.font = 'bold 12px Arial';
                    ctx.fillText(enemy.health, enemy.x, enemy.y);
                }
            });
            ctx.restore();
        }

        // Draw Bullets
        function drawBullets() {
            ctx.save();
            state.bullets.forEach(bullet => {
                ctx.fillStyle = bullet.color;
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Add glow effect
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.size * 2, 0, Math.PI * 2);
                ctx.fillStyle = `${bullet.color.replace(')', `, 0.3)`)}`;
                ctx.fill();
            });
            ctx.restore();
        }

        // Draw Player
        function drawPlayer() {
            ctx.save();
            ctx.translate(state.player.x, state.player.y);
            ctx.rotate(state.player.angle);
            
            // Draw ship
            ctx.fillStyle = state.player.invulnerable && Math.floor(state.gameTime / 100) % 2 === 0 ? 
                          '#ffffff' : COLORS.ship;
            ctx.beginPath();
            ctx.moveTo(state.player.size, 0);
            ctx.lineTo(-state.player.size, -state.player.size / 2);
            ctx.lineTo(-state.player.size / 2, 0);
            ctx.lineTo(-state.player.size, state.player.size / 2);
            ctx.closePath();
            ctx.fill();
            
            // Draw engine glow
            if (state.joystick.active && state.joystick.power > 0.2 || state.keys.up) {
                const power = state.joystick.active ? state.joystick.power : 1;
                ctx.fillStyle = `rgba(255, 0, 255, ${power * 0.7})`;
                ctx.beginPath();
                ctx.moveTo(-state.player.size, -state.player.size / 4);
                ctx.lineTo(-state.player.size * 1.5, 0);
                ctx.lineTo(-state.player.size, state.player.size / 4);
                ctx.closePath();
                ctx.fill();
                
                // Add particles for thrust
                if (state.gameTime % 50 < 20) {
                    createParticles(
                        -state.player.size * 1.5, 
                        0, 
                        Math.floor(power * 3), 
                        COLORS.neonPink,
                        power
                    );
                }
            }
            
            // Draw shield if active
            if (state.player.powerup === 'shield' || state.player.invulnerable) {
                const alpha = state.player.invulnerable ? 
                    (state.player.invulnerableTimer / 2000) * 0.3 : 0.3;
                ctx.strokeStyle = `${COLORS.neonBlue.replace(')', `, ${alpha})`)}`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, state.player.size * 1.5, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.restore();
        }

        // Draw UI
        function drawUI() {
            // Draw score
            scoreDisplay.textContent = `SCORE: ${state.score}`;
            
            // Draw special charge meter
            if (state.player.specialCharge > 0) {
                ctx.save();
                const button = specialButton.getBoundingClientRect();
                const centerX = button.left + button.width / 2 - canvas.offsetLeft;
                const centerY = button.top + button.height / 2 - canvas.offsetTop;
                const radius = button.width / 2 - 5;
                
                // Background circle
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Charged segment
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, -Math.PI/2, -Math.PI/2 + (Math.PI * 2 * state.player.specialCharge / 100));
                ctx.strokeStyle = state.player.specialCharge >= 100 ? '#ffff00' : 'rgba(255, 255, 0, 0.7)';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.restore();
            }
        }

        // Leaderboard Functions
        function setupLeaderboard() {
            const savedLeaderboard = localStorage.getItem('cyberwaveLeaderboard');
            if (savedLeaderboard) {
                state.leaderboard = JSON.parse(savedLeaderboard);
            } else {
                state.leaderboard = [
                    { name: 'ACE', score: 5000 },
                    { name: 'VIP', score: 3000 },
                    { name: 'PRO', score: 2000 },
                    { name: 'NEW', score: 1000 },
                    { name: 'YOU', score: 500 }
                ];
            }
        }

        function updateLeaderboard() {
            // Add current score
            state.leaderboard.push({ name: 'YOU', score: state.score });
            
            // Sort and keep top 5
            state.leaderboard.sort((a, b) => b.score - a.score);
            state.leaderboard = state.leaderboard.slice(0, 5);
            
            // Save to localStorage
            localStorage.setItem('cyberwaveLeaderboard', JSON.stringify(state.leaderboard));
            
            // Display leaderboard
            leaderboard.innerHTML = '';
            const title = document.createElement('h3');
            title.className = 'game-over-text';
            title.textContent = 'LEADERBOARD';
            leaderboard.appendChild(title);
            
            state.leaderboard.forEach(entry => {
                const div = document.createElement('div');
                div.className = 'leaderboard-entry';
                div.innerHTML = `<span>${entry.name}</span><span>${entry.score}</span>`;
                leaderboard.appendChild(div);
            });
        }

        // Service Worker Registration for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js').then(registration => {
                    console.log('ServiceWorker registration successful');
                }).catch(err => {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }

        // Start Game
        window.addEventListener('load', init);
        window.addEventListener('resize', resize);
    </script>
</body>
</html>
